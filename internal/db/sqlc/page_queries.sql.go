// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: page_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPage = `-- name: CreatePage :one

INSERT INTO pages (
    store_id, name, slug, content, draft_content, is_published, type,
    custom_css, custom_js_head, custom_js_body
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, store_id, name, slug, content, draft_content, is_published, type, custom_css, custom_js_head, custom_js_body, created_at, updated_at
`

type CreatePageParams struct {
	StoreID      pgtype.UUID `json:"store_id"`
	Name         string      `json:"name"`
	Slug         string      `json:"slug"`
	Content      []byte      `json:"content"`
	DraftContent []byte      `json:"draft_content"`
	IsPublished  bool        `json:"is_published"`
	Type         string      `json:"type"`
	CustomCss    *string     `json:"custom_css"`
	CustomJsHead *string     `json:"custom_js_head"`
	CustomJsBody *string     `json:"custom_js_body"`
}

// #############################################################################
// ## PAGES (Landing Pages & Custom Designs)
// #############################################################################
func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) (Page, error) {
	row := q.db.QueryRow(ctx, createPage,
		arg.StoreID,
		arg.Name,
		arg.Slug,
		arg.Content,
		arg.DraftContent,
		arg.IsPublished,
		arg.Type,
		arg.CustomCss,
		arg.CustomJsHead,
		arg.CustomJsBody,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Content,
		&i.DraftContent,
		&i.IsPublished,
		&i.Type,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePage = `-- name: DeletePage :exec
DELETE FROM pages
WHERE id = $1 AND store_id = $2
`

type DeletePageParams struct {
	ID      pgtype.UUID `json:"id"`
	StoreID pgtype.UUID `json:"store_id"`
}

func (q *Queries) DeletePage(ctx context.Context, arg DeletePageParams) error {
	_, err := q.db.Exec(ctx, deletePage, arg.ID, arg.StoreID)
	return err
}

const getPage = `-- name: GetPage :one
SELECT id, store_id, name, slug, content, draft_content, is_published, type, custom_css, custom_js_head, custom_js_body, created_at, updated_at FROM pages
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPage(ctx context.Context, id pgtype.UUID) (Page, error) {
	row := q.db.QueryRow(ctx, getPage, id)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Content,
		&i.DraftContent,
		&i.IsPublished,
		&i.Type,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPageBySlug = `-- name: GetPageBySlug :one
SELECT id, store_id, name, slug, content, draft_content, is_published, type, custom_css, custom_js_head, custom_js_body, created_at, updated_at FROM pages
WHERE store_id = $1 AND slug = $2 LIMIT 1
`

type GetPageBySlugParams struct {
	StoreID pgtype.UUID `json:"store_id"`
	Slug    string      `json:"slug"`
}

func (q *Queries) GetPageBySlug(ctx context.Context, arg GetPageBySlugParams) (Page, error) {
	row := q.db.QueryRow(ctx, getPageBySlug, arg.StoreID, arg.Slug)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Content,
		&i.DraftContent,
		&i.IsPublished,
		&i.Type,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPages = `-- name: ListPages :many
SELECT id, store_id, name, slug, content, draft_content, is_published, type, custom_css, custom_js_head, custom_js_body, created_at, updated_at FROM pages
WHERE store_id = $1
ORDER BY updated_at DESC
`

func (q *Queries) ListPages(ctx context.Context, storeID pgtype.UUID) ([]Page, error) {
	rows, err := q.db.Query(ctx, listPages, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Content,
			&i.DraftContent,
			&i.IsPublished,
			&i.Type,
			&i.CustomCss,
			&i.CustomJsHead,
			&i.CustomJsBody,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishPage = `-- name: PublishPage :one
UPDATE pages
SET 
    content = draft_content,
    is_published = TRUE,
    updated_at = now()
WHERE id = $1 AND store_id = $2
RETURNING id, store_id, name, slug, content, draft_content, is_published, type, custom_css, custom_js_head, custom_js_body, created_at, updated_at
`

type PublishPageParams struct {
	ID      pgtype.UUID `json:"id"`
	StoreID pgtype.UUID `json:"store_id"`
}

// Copies draft_content to content and sets is_published = true
func (q *Queries) PublishPage(ctx context.Context, arg PublishPageParams) (Page, error) {
	row := q.db.QueryRow(ctx, publishPage, arg.ID, arg.StoreID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Content,
		&i.DraftContent,
		&i.IsPublished,
		&i.Type,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePage = `-- name: UpdatePage :one
UPDATE pages
SET 
    name = COALESCE($3, name),
    slug = COALESCE($4, slug),
    content = COALESCE($5, content),
    draft_content = COALESCE($6, draft_content),
    is_published = COALESCE($7, is_published),
    type = COALESCE($8, type),
    custom_css = COALESCE($9, custom_css),
    custom_js_head = COALESCE($10, custom_js_head),
    custom_js_body = COALESCE($11, custom_js_body)
WHERE id = $1 AND store_id = $2
RETURNING id, store_id, name, slug, content, draft_content, is_published, type, custom_css, custom_js_head, custom_js_body, created_at, updated_at
`

type UpdatePageParams struct {
	ID           pgtype.UUID `json:"id"`
	StoreID      pgtype.UUID `json:"store_id"`
	Name         *string     `json:"name"`
	Slug         *string     `json:"slug"`
	Content      []byte      `json:"content"`
	DraftContent []byte      `json:"draft_content"`
	IsPublished  *bool       `json:"is_published"`
	Type         *string     `json:"type"`
	CustomCss    *string     `json:"custom_css"`
	CustomJsHead *string     `json:"custom_js_head"`
	CustomJsBody *string     `json:"custom_js_body"`
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) (Page, error) {
	row := q.db.QueryRow(ctx, updatePage,
		arg.ID,
		arg.StoreID,
		arg.Name,
		arg.Slug,
		arg.Content,
		arg.DraftContent,
		arg.IsPublished,
		arg.Type,
		arg.CustomCss,
		arg.CustomJsHead,
		arg.CustomJsBody,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Content,
		&i.DraftContent,
		&i.IsPublished,
		&i.Type,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
