// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignCategoryToProduct = `-- name: AssignCategoryToProduct :exec
INSERT INTO product_categories (product_id, category_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssignCategoryToProductParams struct {
	ProductID  pgtype.UUID `json:"product_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) AssignCategoryToProduct(ctx context.Context, arg AssignCategoryToProductParams) error {
	_, err := q.db.Exec(ctx, assignCategoryToProduct, arg.ProductID, arg.CategoryID)
	return err
}

const assignOptionValueToVariant = `-- name: AssignOptionValueToVariant :exec
INSERT INTO variant_option_values (variant_id, option_value_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssignOptionValueToVariantParams struct {
	VariantID     pgtype.UUID `json:"variant_id"`
	OptionValueID pgtype.UUID `json:"option_value_id"`
}

func (q *Queries) AssignOptionValueToVariant(ctx context.Context, arg AssignOptionValueToVariantParams) error {
	_, err := q.db.Exec(ctx, assignOptionValueToVariant, arg.VariantID, arg.OptionValueID)
	return err
}

const createCategory = `-- name: CreateCategory :one

INSERT INTO categories (
    parent_id, name, slug, description, is_active
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, parent_id, name, slug, description, is_active, created_at, updated_at
`

type CreateCategoryParams struct {
	ParentID    pgtype.UUID `json:"parent_id"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description *string     `json:"description"`
	IsActive    bool        `json:"is_active"`
}

// #############################################################################
// ## CATEGORIES
// #############################################################################
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.ParentID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.IsActive,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOptionTemplate = `-- name: CreateOptionTemplate :one

INSERT INTO option_templates (name, template_data)
VALUES ($1, $2)
RETURNING id, name, template_data, created_at, updated_at
`

type CreateOptionTemplateParams struct {
	Name         string `json:"name"`
	TemplateData []byte `json:"template_data"`
}

// #############################################################################
// ## OPTION TEMPLATES
// #############################################################################
func (q *Queries) CreateOptionTemplate(ctx context.Context, arg CreateOptionTemplateParams) (OptionTemplate, error) {
	row := q.db.QueryRow(ctx, createOptionTemplate, arg.Name, arg.TemplateData)
	var i OptionTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TemplateData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO products (
    name, slug, description, is_active, is_digital
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, name, slug, description, is_active, is_digital, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name        string  `json:"name"`
	Slug        string  `json:"slug"`
	Description *string `json:"description"`
	IsActive    bool    `json:"is_active"`
	IsDigital   bool    `json:"is_digital"`
}

// #############################################################################
// ## PRODUCTS
// #############################################################################
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.IsActive,
		arg.IsDigital,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.IsDigital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductKey = `-- name: CreateProductKey :one

INSERT INTO product_keys (variant_id, key_value)
VALUES ($1, $2)
RETURNING id, variant_id, key_value, is_used, order_id, used_at, created_at, updated_at
`

type CreateProductKeyParams struct {
	VariantID pgtype.UUID `json:"variant_id"`
	KeyValue  string      `json:"key_value"`
}

// #############################################################################
// ## DIGITAL INVENTORY
// #############################################################################
func (q *Queries) CreateProductKey(ctx context.Context, arg CreateProductKeyParams) (ProductKey, error) {
	row := q.db.QueryRow(ctx, createProductKey, arg.VariantID, arg.KeyValue)
	var i ProductKey
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.KeyValue,
		&i.IsUsed,
		&i.OrderID,
		&i.UsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductOption = `-- name: CreateProductOption :one

INSERT INTO product_options (product_id, name, position)
VALUES ($1, $2, $3)
RETURNING id, product_id, name, position
`

type CreateProductOptionParams struct {
	ProductID pgtype.UUID `json:"product_id"`
	Name      string      `json:"name"`
	Position  int32       `json:"position"`
}

// #############################################################################
// ## OPTIONS & VARIANTS
// #############################################################################
func (q *Queries) CreateProductOption(ctx context.Context, arg CreateProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, createProductOption, arg.ProductID, arg.Name, arg.Position)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Position,
	)
	return i, err
}

const createProductOptionValue = `-- name: CreateProductOptionValue :one
INSERT INTO product_option_values (option_id, value, position)
VALUES ($1, $2, $3)
RETURNING id, option_id, value, position
`

type CreateProductOptionValueParams struct {
	OptionID pgtype.UUID `json:"option_id"`
	Value    string      `json:"value"`
	Position int32       `json:"position"`
}

func (q *Queries) CreateProductOptionValue(ctx context.Context, arg CreateProductOptionValueParams) (ProductOptionValue, error) {
	row := q.db.QueryRow(ctx, createProductOptionValue, arg.OptionID, arg.Value, arg.Position)
	var i ProductOptionValue
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Value,
		&i.Position,
	)
	return i, err
}

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (
    product_id, sku, price, stock_quantity, is_active
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, product_id, sku, price, stock_quantity, is_active, created_at, updated_at, deleted_at
`

type CreateProductVariantParams struct {
	ProductID     pgtype.UUID    `json:"product_id"`
	Sku           *string        `json:"sku"`
	Price         pgtype.Numeric `json:"price"`
	StockQuantity int32          `json:"stock_quantity"`
	IsActive      bool           `json:"is_active"`
}

func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, createProductVariant,
		arg.ProductID,
		arg.Sku,
		arg.Price,
		arg.StockQuantity,
		arg.IsActive,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteOptionTemplate = `-- name: DeleteOptionTemplate :exec
DELETE FROM option_templates
WHERE id = $1
`

func (q *Queries) DeleteOptionTemplate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOptionTemplate, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getAvailableKey = `-- name: GetAvailableKey :one
SELECT id, variant_id, key_value, is_used, order_id, used_at, created_at, updated_at FROM product_keys
WHERE variant_id = $1 AND is_used = FALSE
LIMIT 1
FOR UPDATE SKIP LOCKED
`

// Retrieves an available key for a variant and locks the row
// to prevent race conditions during checkout.
func (q *Queries) GetAvailableKey(ctx context.Context, variantID pgtype.UUID) (ProductKey, error) {
	row := q.db.QueryRow(ctx, getAvailableKey, variantID)
	var i ProductKey
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.KeyValue,
		&i.IsUsed,
		&i.OrderID,
		&i.UsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategory = `-- name: GetCategory :one
SELECT id, parent_id, name, slug, description, is_active, created_at, updated_at FROM categories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCategory(ctx context.Context, id pgtype.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, parent_id, name, slug, description, is_active, created_at, updated_at FROM categories
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionTemplate = `-- name: GetOptionTemplate :one
SELECT id, name, template_data, created_at, updated_at FROM option_templates
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOptionTemplate(ctx context.Context, id pgtype.UUID) (OptionTemplate, error) {
	row := q.db.QueryRow(ctx, getOptionTemplate, id)
	var i OptionTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TemplateData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, name, slug, description, is_active, is_digital, created_at, updated_at, deleted_at FROM products
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProduct(ctx context.Context, id pgtype.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.IsDigital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id, name, slug, description, is_active, is_digital, created_at, updated_at, deleted_at FROM products
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.IsDigital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getVariant = `-- name: GetVariant :one
SELECT id, product_id, sku, price, stock_quantity, is_active, created_at, updated_at, deleted_at FROM product_variants
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVariant(ctx context.Context, id pgtype.UUID) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getVariant, id)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, parent_id, name, slug, description, is_active, created_at, updated_at FROM categories
ORDER BY name ASC
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionTemplates = `-- name: ListOptionTemplates :many
SELECT id, name, template_data, created_at, updated_at FROM option_templates
ORDER BY name ASC
`

func (q *Queries) ListOptionTemplates(ctx context.Context) ([]OptionTemplate, error) {
	rows, err := q.db.Query(ctx, listOptionTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OptionTemplate{}
	for rows.Next() {
		var i OptionTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TemplateData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductVariants = `-- name: ListProductVariants :many
SELECT id, product_id, sku, price, stock_quantity, is_active, created_at, updated_at, deleted_at FROM product_variants
WHERE product_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListProductVariants(ctx context.Context, productID pgtype.UUID) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, listProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductVariant{}
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT p.id, p.name, p.slug, p.description, p.is_active, p.is_digital, p.created_at, p.updated_at, p.deleted_at FROM products p
LEFT JOIN product_categories pc ON p.id = pc.product_id
WHERE 
    ($3::uuid IS NULL OR pc.category_id = $3)
    AND ($4::text IS NULL OR 
         p.name ILIKE '%' || $4 || '%' OR 
         p.description ILIKE '%' || $4 || '%')
    AND ($5::boolean IS NULL OR p.is_active = $5)
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	CategoryID pgtype.UUID `json:"category_id"`
	Search     *string     `json:"search"`
	IsActive   *bool       `json:"is_active"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.Search,
		arg.IsActive,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.IsActive,
			&i.IsDigital,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markKeyAsUsed = `-- name: MarkKeyAsUsed :one
UPDATE product_keys
SET 
    is_used = TRUE,
    used_at = now(),
    order_id = $2
WHERE id = $1
RETURNING id, variant_id, key_value, is_used, order_id, used_at, created_at, updated_at
`

type MarkKeyAsUsedParams struct {
	ID      pgtype.UUID `json:"id"`
	OrderID pgtype.UUID `json:"order_id"`
}

func (q *Queries) MarkKeyAsUsed(ctx context.Context, arg MarkKeyAsUsedParams) (ProductKey, error) {
	row := q.db.QueryRow(ctx, markKeyAsUsed, arg.ID, arg.OrderID)
	var i ProductKey
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.KeyValue,
		&i.IsUsed,
		&i.OrderID,
		&i.UsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeCategoryFromProduct = `-- name: RemoveCategoryFromProduct :exec
DELETE FROM product_categories
WHERE product_id = $1 AND category_id = $2
`

type RemoveCategoryFromProductParams struct {
	ProductID  pgtype.UUID `json:"product_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) RemoveCategoryFromProduct(ctx context.Context, arg RemoveCategoryFromProductParams) error {
	_, err := q.db.Exec(ctx, removeCategoryFromProduct, arg.ProductID, arg.CategoryID)
	return err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET 
    parent_id = COALESCE($2, parent_id),
    name = COALESCE($3, name),
    slug = COALESCE($4, slug),
    description = COALESCE($5, description),
    is_active = COALESCE($6, is_active)
WHERE id = $1
RETURNING id, parent_id, name, slug, description, is_active, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          pgtype.UUID `json:"id"`
	ParentID    pgtype.UUID `json:"parent_id"`
	Name        *string     `json:"name"`
	Slug        *string     `json:"slug"`
	Description *string     `json:"description"`
	IsActive    *bool       `json:"is_active"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.ParentID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.IsActive,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET 
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    is_active = COALESCE($5, is_active),
    is_digital = COALESCE($6, is_digital)
WHERE id = $1
RETURNING id, name, slug, description, is_active, is_digital, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        *string     `json:"name"`
	Slug        *string     `json:"slug"`
	Description *string     `json:"description"`
	IsActive    *bool       `json:"is_active"`
	IsDigital   *bool       `json:"is_digital"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.IsActive,
		arg.IsDigital,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IsActive,
		&i.IsDigital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
