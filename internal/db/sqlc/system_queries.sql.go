// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: system_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRoleToUserInStore = `-- name: AssignRoleToUserInStore :exec
INSERT INTO user_store_roles (user_id, store_id, role_id)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type AssignRoleToUserInStoreParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	StoreID pgtype.UUID `json:"store_id"`
	RoleID  pgtype.UUID `json:"role_id"`
}

func (q *Queries) AssignRoleToUserInStore(ctx context.Context, arg AssignRoleToUserInStoreParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUserInStore, arg.UserID, arg.StoreID, arg.RoleID)
	return err
}

const assignSaasRoleToUser = `-- name: AssignSaasRoleToUser :exec
INSERT INTO user_saas_roles (user_id, role_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssignSaasRoleToUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	RoleID pgtype.UUID `json:"role_id"`
}

func (q *Queries) AssignSaasRoleToUser(ctx context.Context, arg AssignSaasRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignSaasRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const createRole = `-- name: CreateRole :one

INSERT INTO roles (tenant_id, name, description, scope, permissions, is_template)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, name, description, scope, permissions, is_template, created_at, updated_at
`

type CreateRoleParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	Scope       RoleScope   `json:"scope"`
	Permissions []string    `json:"permissions"`
	IsTemplate  bool        `json:"is_template"`
}

// #############################################################################
// ## ROLES & PERMISSIONS
// #############################################################################
func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.Scope,
		arg.Permissions,
		arg.IsTemplate,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Scope,
		&i.Permissions,
		&i.IsTemplate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStore = `-- name: CreateStore :one

INSERT INTO stores (
    tenant_id, name, slug, domain, settings,
    config, custom_css, custom_js_head, custom_js_body
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, tenant_id, name, slug, domain, settings, created_at, updated_at, config, custom_css, custom_js_head, custom_js_body, compiled_css_url
`

type CreateStoreParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	Name         string      `json:"name"`
	Slug         string      `json:"slug"`
	Domain       *string     `json:"domain"`
	Settings     []byte      `json:"settings"`
	Config       []byte      `json:"config"`
	CustomCss    *string     `json:"custom_css"`
	CustomJsHead *string     `json:"custom_js_head"`
	CustomJsBody *string     `json:"custom_js_body"`
}

// #############################################################################
// ## STORES
// #############################################################################
func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRow(ctx, createStore,
		arg.TenantID,
		arg.Name,
		arg.Slug,
		arg.Domain,
		arg.Settings,
		arg.Config,
		arg.CustomCss,
		arg.CustomJsHead,
		arg.CustomJsBody,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Config,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CompiledCssUrl,
	)
	return i, err
}

const createTenant = `-- name: CreateTenant :one

INSERT INTO tenants (name, billing_email, status)
VALUES ($1, $2, $3)
RETURNING id, name, billing_email, status, created_at, updated_at
`

type CreateTenantParams struct {
	Name         string  `json:"name"`
	BillingEmail *string `json:"billing_email"`
	Status       string  `json:"status"`
}

// #############################################################################
// ## TENANTS
// #############################################################################
func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant, arg.Name, arg.BillingEmail, arg.Status)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BillingEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStore = `-- name: GetStore :one
SELECT id, tenant_id, name, slug, domain, settings, created_at, updated_at, config, custom_css, custom_js_head, custom_js_body, compiled_css_url FROM stores
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStore(ctx context.Context, id pgtype.UUID) (Store, error) {
	row := q.db.QueryRow(ctx, getStore, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Config,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CompiledCssUrl,
	)
	return i, err
}

const getStoreByDomain = `-- name: GetStoreByDomain :one
SELECT id, tenant_id, name, slug, domain, settings, created_at, updated_at, config, custom_css, custom_js_head, custom_js_body, compiled_css_url FROM stores
WHERE domain = $1 LIMIT 1
`

func (q *Queries) GetStoreByDomain(ctx context.Context, domain *string) (Store, error) {
	row := q.db.QueryRow(ctx, getStoreByDomain, domain)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Config,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CompiledCssUrl,
	)
	return i, err
}

const getStoreBySlug = `-- name: GetStoreBySlug :one
SELECT id, tenant_id, name, slug, domain, settings, created_at, updated_at, config, custom_css, custom_js_head, custom_js_body, compiled_css_url FROM stores
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetStoreBySlug(ctx context.Context, slug string) (Store, error) {
	row := q.db.QueryRow(ctx, getStoreBySlug, slug)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Config,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CompiledCssUrl,
	)
	return i, err
}

const getTenant = `-- name: GetTenant :one
SELECT id, name, billing_email, status, created_at, updated_at FROM tenants
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTenant(ctx context.Context, id pgtype.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenant, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BillingEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSaasRoles = `-- name: GetUserSaasRoles :many
SELECT r.id, r.tenant_id, r.name, r.description, r.scope, r.permissions, r.is_template, r.created_at, r.updated_at FROM roles r
JOIN user_saas_roles usr ON r.id = usr.role_id
WHERE usr.user_id = $1
`

func (q *Queries) GetUserSaasRoles(ctx context.Context, userID pgtype.UUID) ([]Role, error) {
	rows, err := q.db.Query(ctx, getUserSaasRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Scope,
			&i.Permissions,
			&i.IsTemplate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoreRoles = `-- name: GetUserStoreRoles :many
SELECT r.id, r.tenant_id, r.name, r.description, r.scope, r.permissions, r.is_template, r.created_at, r.updated_at FROM roles r
JOIN user_store_roles usr ON r.id = usr.role_id
WHERE usr.user_id = $1 AND usr.store_id = $2
`

type GetUserStoreRolesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	StoreID pgtype.UUID `json:"store_id"`
}

func (q *Queries) GetUserStoreRoles(ctx context.Context, arg GetUserStoreRolesParams) ([]Role, error) {
	rows, err := q.db.Query(ctx, getUserStoreRoles, arg.UserID, arg.StoreID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Scope,
			&i.Permissions,
			&i.IsTemplate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesByTenant = `-- name: ListRolesByTenant :many
SELECT id, tenant_id, name, description, scope, permissions, is_template, created_at, updated_at FROM roles
WHERE tenant_id = $1 OR tenant_id IS NULL -- Include system roles
ORDER BY name ASC
`

func (q *Queries) ListRolesByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRolesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Scope,
			&i.Permissions,
			&i.IsTemplate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoresByTenant = `-- name: ListStoresByTenant :many
SELECT id, tenant_id, name, slug, domain, settings, created_at, updated_at, config, custom_css, custom_js_head, custom_js_body, compiled_css_url FROM stores
WHERE tenant_id = $1
ORDER BY name ASC
`

func (q *Queries) ListStoresByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Store, error) {
	rows, err := q.db.Query(ctx, listStoresByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Slug,
			&i.Domain,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Config,
			&i.CustomCss,
			&i.CustomJsHead,
			&i.CustomJsBody,
			&i.CompiledCssUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenants = `-- name: ListTenants :many
SELECT id, name, billing_email, status, created_at, updated_at FROM tenants
ORDER BY created_at DESC
`

func (q *Queries) ListTenants(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BillingEmail,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStore = `-- name: UpdateStore :one
UPDATE stores
SET 
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    domain = COALESCE($4, domain),
    settings = COALESCE($5, settings),
    config = COALESCE($6, config),
    custom_css = COALESCE($7, custom_css),
    custom_js_head = COALESCE($8, custom_js_head),
    custom_js_body = COALESCE($9, custom_js_body),
    compiled_css_url = COALESCE($10, compiled_css_url)
WHERE id = $1
RETURNING id, tenant_id, name, slug, domain, settings, created_at, updated_at, config, custom_css, custom_js_head, custom_js_body, compiled_css_url
`

type UpdateStoreParams struct {
	ID             pgtype.UUID `json:"id"`
	Name           *string     `json:"name"`
	Slug           *string     `json:"slug"`
	Domain         *string     `json:"domain"`
	Settings       []byte      `json:"settings"`
	Config         []byte      `json:"config"`
	CustomCss      *string     `json:"custom_css"`
	CustomJsHead   *string     `json:"custom_js_head"`
	CustomJsBody   *string     `json:"custom_js_body"`
	CompiledCssUrl *string     `json:"compiled_css_url"`
}

func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) (Store, error) {
	row := q.db.QueryRow(ctx, updateStore,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Domain,
		arg.Settings,
		arg.Config,
		arg.CustomCss,
		arg.CustomJsHead,
		arg.CustomJsBody,
		arg.CompiledCssUrl,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Config,
		&i.CustomCss,
		&i.CustomJsHead,
		&i.CustomJsBody,
		&i.CompiledCssUrl,
	)
	return i, err
}
